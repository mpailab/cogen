# Возможные направления исследования

## Улучшения алгоритмов построения логического вывода основанные на нейросетях

**Замечание:** данный раздел написан НЕ специалистом по нейросетям, поэтому нужно обсудить со специалистом в этой области.

Нейросети можно использовать в качестве "интуиции" при решении задач. Сам логический вывод при этом можно производить обычным применением приёмов. Нейросети можно использовать при планировании решения, например, для следующих сценариев:

1. При оценке полезности вывода заданного утверждения из заданного списка посылок при заданной цели (например, в виде утверждения, которое нужно доказать).
2. При оценке полезности перехода от задачи к подзадаче при заданном списке посылок.

### Кодирование термов и архитектура сети

Для работы с термами кажется логичным использовать свёрточные нейронные сети на графах (скорее всего, даже на деревьях). Логические символы можно кодировать двоичным кодом символа (можно -- разреженным кодом), подключив ко входам несколько слоёв, которые смогут классифицировать логические символы и выделить полезные признаки, которые далее и будут подаваться на свёрточную сеть. Также ко входу можно искусственно добавить те признаки, которые заведомо должны быть полезны, такие как коммутативность/ассоциативность.

Свёрточные слои следует применить ко всем посылкам, целевому терму и проверяемому терму. Для каждого из трёх типов термов слои сети должны быть независимы. Выход свёрточной части должен, по-видимому, браться с корневых вершин последнего слоя (глубина самих термов заранее неизвестна и может изменяться).

Если в задаче имеются дополнительные целевые установки в виде флагов, имеет смысл их подавать в качестве дополнительных входов на некоторые свёрточные слои.

Выходы свёрточных слоёв посылок необходимо подать на некоторую масштабируемую сеть, которая соберёт выходы неограниченного числа посылок в некоторое фиксированное число выходов. Может быть, подойдёт рекуррентная сеть или просто набор пороговых элементов с переменным числом входов. Целью подсети, обрабатывающей посылки, является выявления наличие/отсутсвие посылок с определёнными свойствами.  

После обработки посылок все выходы (посылки + целевой терм + проверяемый терм) подать на несколько полносвязных слоёв.

### Слабые места подхода

1. Практически всегда изменение одной переменной на другую в одном месте кардинально меняет оценку полезности и вообще корректность задачи. Крайне важной подзадачей при определении полезности или возможности вывода следствия из посылок является задача унификации подтермов как внутри одного терма, так и в разных частях задачи.
2. Небольшая обучающая выборка.
3. Данный подход не предполагает, чтобы сеть сама давала рекомендации. Она может использоваться лишь для выбора из нескольких путей решения наиболее предпочтительного с её точки зрения. Зато именно в этом случае может быть первый недостаток не так существенен, поскольку все термы заведомо корректно конструируются логической частью системы.
4. Подход никак не автоматизирует процесс создания приёмов.
5. Попытки применять подобные подходы периодически предпринимаются но успехи достаточно скромные. Возможно, это связано с несамостоятельностью базовой системы логического вывода (например, Coq).

### Возможные преимущества перед чисто логиченским подходом и чисто нейросетевым подходом

1. Автоматическая оптимизация фильтров приёмов: если подход в принципе работает, и кроме того имеется набор приёмов, который так или иначе позволяет решать некоторый класс задач, то автоматически из трассировки получается обучающая выборка, и сеть научится отфильтровывать тупиковые ветки решения.
2. Скорее всего, наиболее правильная оценка полезности применения приёма достаточно плохо записывается в логическом виде (как набор фильтров), и вручную невозможно сформулировать хороший критерий применимости приёма в виде относительно короткого описания, а нейросеть предоставляет путь автоматически получить такое описание  в виде весов. Хоть это описание и очень длинное (в сети много слоёв, в каждом слое много фильтров), но оно сразу может использоваться для разных типов приёмов.
3. Нейронная сеть "не несёт ответственность" за корректность применения преобразований.
4. Нейросеть может избавить от необходимости писать фильтры для свежесоздаваемых приёмов, поскольку она оценивает не применимость конкретного приёма, а целесообразность и возможность вывода терма, получающегося в результате применения приёма (не важно какого).

## Автоматизация создания приёмов

### Создание приёма из последовательности шагов решения задачи

Автоматизация создания приёмов может быть основана на запоминании последовательности шагов решения, которая повторяется в различных решениях. Для создании подобной процедуры должна быть процедура, которая по данной последовательности шагов создаёт приём, в частности:

* Проверяет, какие какие результаты промежуточных шагов используются в дальнейшем решении
* Переобозначает несущественные подтермы через переменные. Пытается максимально обобщить последовательность шагов, исходя из приёмов, которые применялись на этих шагах
* Объединяет все условия применения приёма с разных шагов
* Удаляет условия применения приёма, которые в данной последовательности всегда выполнены
* Оценивает, что проще: применить полученный приём или исходную последовательность шагов. Если полученный приём не проще, то он удаляется.

Также нужна функция эффективности набора приёмов для класса задач. Например, в качестве обратной величины можно взять суммарное время решения всех задач + некоторый штраф за каждую нерешённую задачу.
Имея такую процедуру и функцию эффективности, создание новых приёмов может выглядеть следующим образом:

* Прогоняем решение большого количества задач из заданной области
* На основе всех цепей шагов, возникших в процессе решения создаём приёмы
* Извлекаем некоторым алгоритмом оптимизации наиболее эффективное подмножество из набора полученных приёмов. Например, ввести каким-либо разумным образом функцию полезности одного приёма, упорядочить все приёмы по полезности и бинарным поиском найти, сколько наименее полезных приёмов нужно удалить, чтобы получить наиболее эффективное подмножество.

### Вывод приёмов напрямую из аксиом и существующих приёмов

Для прямого вывода приёмов необходима относительно быстрая оценка полезности приёма и оценки вероятности, что промежуточный результат приведёт к полезному приёму, например, статистическим методом или с использованием нейросети. Алгоритм может быть следующим:

* Комбинируем различным образом существующие приёмы и аксиомы и генерируем некоторое множество приёмов.
* Тренируем сеть оценивать полезность приёма на уже имеющихся (хороших) приёмах и свежесгенерированных (в основном плохих)
* Снова запускаем процедуру комбинирования аксиом и имеющихся приёмов и следим за оценкой полезности получающегося приёма, тренируя сеть на промежуточных шагах оценивать полезность промежуточного результата. В таком режиме обученаем сеть и одновременно получаем большое количество приёмов, из которых периодически можно выбирать произвольное подмножество и прогонять на задачах, оценивая их полезность и дообучая сеть.

#### Недостатки подхода

* Необходима архитектура сети, которая смогла воспринимать структуру приёма, чтобы оценивать его полезность. Либо нужен какой-либо ещё алгоритм машинного обучения, способный классифицировать наборы термов разных типов.
* Необходимо, чтобы была предсказуема не только полезность приёма, но и веротность, что данная ветвь перебопа приведёт к полезному приёму. Иначе процедура поиска быстро увязнет в переборе.
* Невозможность холодного старта. Для запуска алгоритма нужен набор рабочих приёмов, позволяющих решать хоть какие-то задачи, чтобы инициировать оценку полезности приёмов.

## Автоматизация деления задач на подзадачи

Если мы пытаемся придать системе некоторую математическую интуицию, то в некоторый момент понадобится и способность по задаче формулировать подзадачи, которые кажется, что возможно решить и что они будут полезны для решения всей задачи. Сейчас это делается некоторрыми приёмами, где вся необходимая информация зашита вручную.

Как использовать нейросети или статистические методы для этой цели &mdash; не очень понятно, поскольку выходом должна быть сложная структура подзадачи, причём в строгом виде, чтобы логическая часть системы могла с ней работать.
