# Pattern matching в идентификационной части приёмов

## Общая схема идентификации приёма
1. **Первичная идентификация.** Чтобы приём сработал, в задаче должны присутствовать посылки или условия определённого вида. При разборе теоремы приёма явно выписывается список шаблонов, из которых некоторые должны идентифицироваться с посылками задачи, некоторые -- с условиями, некоторые -- с подтермами посылок или условий. При идентификации определяются подтермы, соответствующие переменным шаблонов.

  Каждый из шаблонов может быть уточнён при помощи указателей идентификации, указанных в приёме.

  Кроме шаблонов, взятых из теоремы, могут быть дополнительные шаблоны или условия применения приёма, указанные в его фильтрах.
2. **Окончательная идентификация.** После идентификации посылок и условий задачи с шаблонами начинается проверка оставшишся условий применения приёма путём обращения к проверочным операторам. Здесь могут формироваться небольшие подзадачи.

## Pattern matching для первичной идентификации

Фактически, при первичной идентификации происходит сопоставление посылок и условий задачи с образцами. Например, в приёме вывода следствий теорема имеет вид
\f[\forall x_1...x_n (A_1,A_2,...,A_m \to B)\f]
Некоторые из термов \f$A_1,...,A_m\f$ идентифицируются с посылками задачи при первичной идентификации (пусть это \f$A_1,...,A_k\f$), а остальные -- проверяются во время окончательной идентификации.

Идентификация списка термов с посылками задачи может быть записана на языке coral в виде сопоставления с образцом:
```coral
[A1,...,Ak]++_ ~= premises
```
При использовании подобного оператора в идентификационной части программы вся сложность задачи перекладывается на алгоритм сопоставления с образцом, который создаётся компилятором языка coral при компиляции приёма.

### Задача компилятора языка coral

После генерации идентифицирующей части всех приёмов образуется множество шаблонов, сопоставление с которыми нужно выполнять одновременно во время решения задачи. Если выполнять сопоставление со всеми образцами последовательно, то время решения задачи будет линейно зависеть от количества имеющихся приёмов, из которых большинство в принципе неприменимы к подобным задачам.

Компилятор языка coral должен составить такую процедуру сопоставления, при которой шаблоны, которые заведомо не подходят, не будут даже просматриваться при решении задачи. То есть, основная часть приёмов должна быть отсеяна без попыток идентифиции частью.

Для решения этой задачи можно построить вспомогательную структуру данных, которая позволяла бы в зависимости от задачи обходить лишь небольшое подмножество приёмов, для которых уже можно применить обычную процедуру сопоставления с образцом.


### Как это сделано в решателе
В решателе каждый приём привязан к логическому символу. В терминах нашей задачи это означает, что каждому набору шаблонов сопоставлен некоторый логический символ, входящий в один из шаблонов.

Сопоставление с образцом происходит в процессе сканирования задачи. Последовательно просматриваются все термы задачи, и для каждого логического символа, встречающегося в задаче, просматриваются все шаблоны, которые включают в себя этот символ.

#### Преимущества
* Никогда не просматриваются шаблоны, привязанные к логическим символам, не встречающимся в задаче.
* Быстро отсеиваются многие шаблоны при просмотре ближайшей окрестности символа задачи, к которому привязан шаблон.

#### Недостатки
* К наиболее распространённым логическим символам привязано очень много приёмов. Такие символы встречаются во многих задачах в большом количестве.
* Учитывая систему переключения внимания, используемую в решателе, возможность срабатывания приёма в задаче зависит от символа, к которому привязан приём. Если приём не сработал, когда посылка, содержащая символ, к которому он привязан, имела вес, соответствующий уровню срабатывания приёма, то вес посылки увеличится, и приём уже не сработает для этой задачи, даже если другие необходимые условия будут добавлены в процессе решения.

  В свою очередь, символ, к которому привязан приём, определяется, исходя из равномерности распределения приёмов по символам с целью оптимизации процедуры сканирования. Не очень понятно, как такая оптимизация отражается на качестве.

### Как это можно реализовать в языке coral

Для простоты будем считать, что программа приёма имеет конечное множество входных переменных и представляет собой бинарный ориентированный ациклический граф с корнем (корень сверху), вершинам которого приписаны объекты двух типов:
* уравнения \f$F(x_1,...,x_n) = G(y_1,...,y_m)\f$, где F, G &mdash; формулы в одном языке. При этом переменные \f$x_i\f$ являются неизвестными, т.е. не встречаются в вышестоящих вершинах и не являются входными переменными, а переменные \f$y_i\f$, наоборот, являются известными.
* предикаты \f$P(x_1,...,x_n)\f$. При этом все переменные xiявляются известными.

Из каждой вершины исходит два ребра, соответствующих истинному и ложному значению соответствующего уравнения или предиката. При этом уравнение считается истинным, если оно разрешимо. Дуги первого типа будем называть *истинными*, а дуги второго типа &mdash; *ложными*.

На первом шаге алгоритма упростим все уравнения с помощью унифицирующих подстановок, т.е. сведем все уравнения к уравнениям вида
\f$x = G(y_1,...,y_m)\f$  и  \f$F(x_1,...,x_n) = y\f$.

Уравнения первого типа будем называть *определяющими*, а уравнения второго типа &mdash; *ограничивающими*. При этом все вырожденные уравнения вида \f$x=y\f$ удаляются простой заменой \f$x\f$ на \f$y\f$.

Далее, алгоритм применяет упрощающее преобразование. На вход упрощающего преобразования подается произвольное определяющее уравнение \f$x = G\f$ и все достижимые из него ограничивающие уравнения \f$F_1=x, ..., F_n=x\f$. Затем определяющее уравнение заменяется на псевдо уравнение вида \f$\langle F_1, ..., F_n\rangle = G\f$ и каждое ограничивающее уравнение заменяется на предикат \f$F_i\f$ *is defined*, который истинен, если все переменные в \f$F_i\f$ определены, т.е. они являются решениями вышестоящих уравнений, которые в свою очередь разрешимы.

После этого алгоритм пытается разрешить все псевдо уравнения. Рассмотрим несколько случаев:
1. \f$F_i= f(F_1^i,...,F_m^i)\f$ для всех \f$1\le i\le n\f$. Тогда, либо

  1. \f$G = y\f$ для некоторой переменной \f$y\f$. В этом случае, ничего не   делаем, т.к. на следующем шаге алгоритма данное псевдо уравнение будет воспринято как ограничивающее уравнение и к нему будет применено упрощающее преобразование.

  2. \f$G = g(...)\f$ и \f$f\ne g\f$, т.е. псевдо уравнение неразрешимо. В этом случае, все предикаты \f$F_i\f$ *is defined* заменяем на *False*, а само псевдо уравнение заменяем на предикат *False*;

  3. \f$G= f(G_1,...,G_m)\f$. В этом случае, заменим псевдо уравнение на последовательность уравнения \f$\langle F^j_1, ..., F^j_n\rangle = G_j\f$ для \f$1\le j\le m\f$. При этом от уравнений с меньшим индексом ведет истинное ребро к уравнению с большим индексом. Для последнего уравнения преемник истинной дуги совпадает с преемником истинной дуги исходного псевдо уравнения.  По ложным дугам переходим туда же, куда переходили по ложной дуге из исходного псевдо уравнения. Заметим, что данная конструкция соответствую конъюнкции в двоичных разрешающих диаграммах (BDD). Поэтому такую конструкцию будем называть *конъюнктивной склейкой* формульных уравнений.

2. \f$F_{i_j}= f_j(F_1^{i_j},...,F_{m_j}^{i_j})\f$ для всех \f$i_j\in I_j\f$ и  \f$1\le j\le k\f$ таких, что \f$I_1,...,I_k\f$ &mdash; это разбиение множества \f$\{1,...,n\}\f$. Тогда, либо

  1. \f$ G = y\f$ для некоторой переменной \f$ y\f$. В этом случае, заменим псевдо уравнение на последовательность уравнений \f$ \langle F_{i_j}: i_j\in I_j\rangle = y\f$ для \f$ 1\le j\le k\f$. При этом от уравнений с меньшим индексом ведет ложное ребро к уравнению с большим индексом. Для последнего уравнения преемник ложной дуги совпадает с преемником ложной дуги исходного псевдо уравнения.  По истинным дугам переходим туда же, куда переходили по истинной дуге из исходного псевдо уравнения. Заметим, что данная конструкция соответствую дизъюнкции в двоичных разрешающих диаграммах (BDD). Поэтому такую конструкцию будем называть *дизъюнктивной склейкой* формульных уравнений.

  2. \f$ G =  f(G_1,...,G_m)\f$. В этом случае, для каждого \f$ j\f$ такого, что  \f$ f\ne f_j\f$, и всех \f$ i_j\in I_j\f$ предикаты \f$ F_{i_j}\f$ *is defined* заменяем на *False* и удаляем соответствующие \f$ F_{i_j}\f$ из псевдо уравнения. Если при этом были удалены все компоненты псевдо уравнения, его также заменяем на *False*, иначе переходим к пункту 1.c.

3. \f$ F_{i_0}=x_{i_0}\f$ для всех \f$ i_0\in I_0\f$ и \f$ F_{i_j}= f_j(F_1^{i_j}, ...,F_{m_j}^{i_j})\f$ для всех \f$ i_j\in I_j\f$, \f$ 1\le j\le k\f$ таких, что \f$ I_0,I_1,...,I_k\f$ &mdash; это разбиение множества {1,...,n}. Тогда, либо

  1. \f$ G = y\f$ для некоторой переменной y. В этом случае, подставим вместо всех переменных \f$ x_{i_0}\f$ для \f$ i_0\in I_0\f$ формулу \f$ G\f$, удалим соответствующие компоненты из псевдо уравнения и перейдем к пункту 2.

  2. \f$ G = f(G_1,...,G_m)\f$. В этом случае, подставим вместо всех переменных \f$ x_{i_0}\f$ для \f$ i_0\in I_0\f$ формулу \f$ f(y_1,...,y_m)\f$, где \f$ y_1,...,y_m\f$ &mdash; новые переменные, удалим все повторы в псевдо уравнении и перейдем к пункту 2.

В заключение, алгоритм применяет упрощающее преобразование уже к псевдо уравнениям, т.е. уравнениям, содержащим внутри себя псевдо конструкции.

Подводя итог, можно отметить следующее:
* расширяется понятие формулы, добавлением конструкций вида \f$ \langle F_1, ..., F_n\rangle\f$;
* уточняется алгоритм решения формульных уравнений для новых конструкций;
* добавляется предикат вида \f$ F\f$ *is defined*.

Рассмотрим класс графов, в которых определение любой переменной x доминирует все её использования, т.е. уравнение, в котором определяется x, содержится на любом пути от корня к уравнению, в котором x используется. К данному классу графов относятся все графы, в которых каждая переменная имеет единственное определение. Работу упрощающего алгоритма в этом случае можно описать так:
1. если в графе есть вершина с нетривиальным уравнением, то разрешаем его и решение, как систему уравнений, внедряем в граф с помощью конъюнктивной склейки;
2. если в графе есть определяющее уравнение \f$ x = G\f$, из которого достижимым ограничивающие уравнения \f$ F_1=x, ..., F_n=x\f$, то заменим его на уравнение \f$ \langle F_1, ..., F_n\rangle = G\f$ и каждое уравнение \f$ F_i=x\f$ заменим на предикат \f$ F_i\f$ *is defined*. После чего переходим к пункту 1.

Отметим, что алгоритм допускает обобщение и на случай графов, в которых могут быть несколько определение одной и той же переменной (например, если программа графа допускает конструкции вида \f$ x = (P\,?\, F : G)\f$). В этом случае, в графе будет два определяющих уравнения \f$ x = F\f$ и \f$ x = G\f$. Если \f$ F_1=x, ..., F_n=x\f$ &mdash; это все достижимые из них ограничивающие уравнения, то достаточно решить уравнение \f$ \langle F_1, ..., F_n\rangle = \langle F,G\rangle\f$ разбором всех случаев.
