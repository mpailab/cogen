# Pattern matching в идентификационной части приёмов

## Общая схема идентификации приёма
1. **Первичная идентификация.** Чтобы приём сработал, в задаче должны присутствовать посылки или условия определённого вида. При разборе теоремы приёма явно выписывается список шаблонов, из которых некоторые должны идентифицироваться с посылками задачи, некоторые -- с условиями, некоторые -- с подтермами посылок или условий. При идентификации определяются подтермы, соответствующие переменным шаблонов.

  Каждый из шаблонов может быть уточнён при помощи указателей идентификации, указанных в приёме.

  Кроме шаблонов, взятых из теоремы, могут быть дополнительные шаблоны или условия применения приёма, указанные в его фильтрах.
2. **Окончательная идентификация.** После идентификации посылок и условий задачи с шаблонами начинается проверка оставшишся условий применения приёма путём обращения к проверочным операторам. Здесь могут формироваться небольшие подзадачи.

## Pattern matching для первичной идентификации

Фактически, при первичной идентификации происходит сопоставление посылок и условий задачи с образцами. Например, в приёме вывода следствий теорема имеет вид
\f[\forall x_1...x_n (A_1,A_2,...,A_m \to B)\f]
Некоторые из термов \f$A_1,...,A_m\f$ идентифицируются с посылками задачи при первичной идентификации (пусть это \f$A_1,...,A_k\f$), а остальные -- проверяются во время окончательной идентификации.

Идентификация списка термов с посылками задачи может быть записана на языке coral в виде сопоставления с образцом:
```coral
[A1,...,Ak]++_ ~= premises
```
При использовании подобного оператора в идентификационной части программы вся сложность задачи перекладывается на алгоритм сопоставления с образцом, который создаётся компилятором языка coral при компиляции приёма.

### Задача компилятора языка coral

После генерации идентифицирующей части всех приёмов образуется множество шаблонов, сопоставление с которыми нужно выполнять одновременно во время решения задачи. Если выполнять сопоставление со всеми образцами последовательно, то время решения задачи будет линейно зависеть от количества имеющихся приёмов, из которых большинство в принципе неприменимы к подобным задачам.

Компилятор языка coral должен составить такую процедуру сопоставления, при которой шаблоны, которые заведомо не подходят, не будут даже просматриваться при решении задачи. То есть, основная часть приёмов должна быть отсеяна без попыток идентифиции частью.

Для решения этой задачи можно построить вспомогательную структуру данных, которая позволяла бы в зависимости от задачи обходить лишь небольшое подмножество приёмов, для которых уже можно применить обычную процедуру сопоставления с образцом.

### Как это сделано в решателе
В решателе каждый приём привязан к логическому символу. В терминах нашей задачи это означает, что каждому набору шаблонов сопоставлен некоторый логический символ, входящий в один из шаблонов.

Сопоставление с образцом происходит в процессе сканирования задачи. Последовательно просматриваются все термы задачи, и для каждого логического символа, встречающегося в задаче, просматриваются все шаблоны, которые включают в себя этот символ.

#### Преимущества
* Никогда не просматриваются шаблоны, привязанные к логическим символам, не встречающимся в задаче.
* Быстро отсеиваются многие шаблоны при просмотре ближайшей окрестности символа задачи, к которому привязан шаблон.

#### Недостатки
* К наиболее распространённым логическим символам привязано очень много приёмов. Такие символы встречаются во многих задачах в большом количестве.
* Учитывая систему переключения внимания, используемую в решателе, возможность срабатывания приёма в задаче зависит от символа, к которому привязан приём. Если приём не сработал, когда посылка, содержащая символ, к которому он привязан, имела вес, соответствующий уровню срабатывания приёма, то вес посылки увеличится, и приём уже не сработает для этой задачи, даже если другие необходимые условия будут добавлены в процессе решения. 

  В свою очередь, символ, к которому привязан приём, определяется, исходя из равномерности распределения приёмов по символам с целью оптимизации процедуры сканирования. Не очень понятно, как такая оптимизация отражается на качестве.

### Как это можно реализовать в языке coral
