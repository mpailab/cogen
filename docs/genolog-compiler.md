# Схема функционирования системы 
\tableofcontents

# Функционирование решателя задач {#solverfunc}

В решателе имеются следующие механизмы решения задач:

1. Цикл сканирования задачи. Здесь просматривается все приёмы из основной базы приёмов
2. Пакетные операторы. Каждый пакетный оператор включает в себя сравнительно небольшой набор приёмов, нацеленных на решение небольшой вспомогательной подзадачи специального вида. 

Основные пакетные операторы:

* проверочный оператор
* синтезатор
* нормализатор
* анализатор

## Цикл сканирования задачи {#scancycle}

Последующее описание взято из раздела 4.1 — "сканирование задачи".

Для организации цикла поиска очередного применяемого приема в решателе используется процедура сканирования задачи, которую можно представлять как своего рода модель внутреннего логического зрения. Для большинства приемов активизация их при рассмотрении задачи начинается с обнаружения в задаче  некоторого логического символа, к которому прикреплён приём (такой символ будем называть *точкой привязки* приёма). В качестве точки привязки берется обычно некоторый логический символ, появление которого необходимо для применения рассматриваемого приёма, причём при нескольких возможных выборах предпочтение отдается наиболее редко встречающемуся логическому символу, исходя из соображений оптимизации. В особых случаях прием не удается связать с каким-либо конкретным логическим символом, появление которого является необходимым для срабатывания. Такие приемы (их совсем немного) распределены по четырем логическим символам — названиям "доказать", "описать", "преобразовать", "исследовать" типов задач, при решении которых возможно их применение.

Текущая ситуация, возникающая в процессе работы решателя, описывается последовательностью задач Z1,Z2, ... ,ZN, где Zi+1 — вспомогательная задача, введенная при решении задачи Zi (i = 1, ... ,N−1). В этой последовательности (далее называем ее *цепью задач*) задача Z1 является фиктивной — она создается автоматически при запуске логической системы и используется для организации интерфейса, а также выполняет функции "доски объявлений" — различные процедуры решателя могут обмениваться между собой сообщениями, размещая их в списке комментариев к посылкам этой задачи. С помощью интерфейса можно ввести некоторую задачу Z2, которая далее и решается, порождая вспомогательные задачи Z3, . . . ,ZN. Будем называть задачу ZN *текущей задачей*; Z2 — *корневой задачей*.

Каждая задача Zi (i = 1, ... ,N) характеризуется натуральным числом Mi, называемым ее *максимальным уровнем* и определяющим уровень средств, отведенных для ее решения (по исчерпании этих средств выдается отказ), целым неотрицательным числом mi &le; Mi, называемым текущим уровнем этой задачи и определяющим уровень средств, среди которых в текущий момент ведется поиск очередного преобразования задачи Zi, а также вспомогательной информацией, необходимой для возобновления прерванной процедуры решения задачи Zi−1 по окончании решения задачи Zi. Текущий уровень задачи является одним из входных параметров, получаемых приемами; он учитывается решающими правилами приемов и позволяет организовать необходимые приоритеты в их применении: при меньших значениях этого уровня срабатывают приемы с большим приоритетом. В процессе обучения решающие правила приемов корректируются таким образом, чтобы на каждом шаге выбирался прием, наиболее целесообразный с точки зрения обучающего систему эксперта. При
первоначальном обращении к задаче Zi ее текущий уровень равен 0.

Изменение текущей ситуации происходит в следующем рабочем цикле решателя:
1. Происходит обращение к программе логического символа f — типа задачи ZN. Если при этом не срабатывает ни один из приемов, либо сработавшие приемы изменили лишь комментарии задач и ни один из них не указал явно на необходимость повторного рассмотрения задачи (в таких случаях говорим, что процедура не внесла существенных изменений в текущую ситуацию), то переход к пункту 3, иначе — к
пункту 2.
2. Если в результате срабатывания приема определился ответ на задачу ZN либо был выдан отказ на нее, то возобновляется прерванный ранее прием решения задачи ZN−1, в процессе реализации которого возникла задача ZN. При N = 2 в этом случае выдается ответ либо отказ на решаемую задачу и возвращение в программу интерфейса решателя; при N = 1 — происходит выход из логической системы. При отсутствии ответа либо отказа на задачу ZN текущий уровень этой задачи заменяется на 0, и переход к пункту 1. Это означает, что при наличии существенных изменений, внесенных приемом, решатель повторяет цикл анализа текущей ситуации с самого начала.
3. Осуществляется последовательный просмотр всех условий и посылок F задачи ZN, вес v которых равен текущему уровню mN этой задачи либо равен mN+1. Сначала просматриваются условия, затем посылки; порядок просмотра условий (посылок) — слева направо по соответствующим спискам задачи ZN. Если v = mN, то происходит однократный просмотр всех вхождений логических символов &phi; в F (слева направо); если же v = mN+1, то — серия таких просмотров, в процессе которых значение текущего уровня задачи ZN полагается последовательно равным 0, 1, ... , mN. Для каждого рассматриваемого вхождения логического символа &phi; в F осуществляется обращение к программе логического символа &phi; (исходные данные этой программы содержат полную информацию о координатах вхождения символа &phi; в задачу ZN). Если процедура не внесла существенных изменений в текущую ситуацию, то переход к рассмотрению очередного вхождения логического символа, иначе — к пункту 2. Если просмотр терма F закончился безрезультатно, то вес его увеличивается на 1 (новые либо видоизмененные посылки и условия задачи получают вес 0). Если просмотр всех условий и посылок задачи ZN закончился безрезультатно, то текущий уровень задачи ZN увеличивается на 1. Если в результате он становится больше, чем максимальный уровень MN, то на задачу ZN выдается отказ, иначе — переход к пункту 1.

Использование весов посылок и условий позволяет сузить область просмотра при поиске очередного приема, исключая из нее посылки и условия, имеющие большой вес (они уже были достаточно хорошо рассмотрены ранее, и срабатывание связанного с ними приема маловероятно). В результате происходит локализация рассмотрения задачи, направляемого в первую очередь на новые либо видоизмененные посылки и условия; рассмотрение же всей задачи в целом имеет место, как правило, лишь на начальном этапе ее решения. По мере повышения текущего уровня mN задачи ZN в просмотр вовлекаются ранее отложенные посылки и условия F, вес v которых больше mN; это происходит при v = mN + 1 (см. пункт 3), причем предварительно осуществляется поиск приема, срабатывающего при рассмотрении F для меньших, чем mN, значений текущего уровня. Переключение внимания при рассмотрении задачи может происходить также в результате срабатывания приемов, уменьшающих веса тех или иных условий и посылок.

### Недостатки {#disadv-scan}

1. Число уровней сканирования фиксировано. Каждый приём привязан к своему уровню, поэтому увеличение числа уровней простым устранения ограничением сверху не приведёт к желаемому результату.

  **Возможное решение:** вместо числового значения уровня срабатывания приёма указывать некоторую строковую метку. На метках потом можно вводить порядок приоритетов, при необходимости вставляя новую метку между двумя существующими. При сканировании задачи при этом каждой метке будет соответствовать конкретное число, и процедура сканирования будет работать точно так же.
2. Ресурсы, отведённые на решение задачи, почти фиксированы. Однако здесь не помешала бы большая гибкость. Например, в зависимости от отведённого времени, можно было бы выделять больше или меньше ресурсов. Максимальный уровень задачи даёт слишком грубую шкалу для регулировки.

  **Возможный путь решения:** может быть следует проводить дополнительную фильтрацию приёмов по какому-то признаку в зависимости от отведённого на задачу времени. Также возможно, когда времени отведено больше, чем обычно, ослаблять временные ограничения на вспомогательные задачи. Возможно ввести какой-то тип приёмов для предварительной оценки времени и сложности решения подзадачи.

## Пакетные операторы {#opgroups}

Последующее описание взято из раздела 10.2.7 —  "Пакетные операторы и их приемы".

Оптимизация решателя оказалась связанной с максимальным увеличением объема вычислений и преобразований, выполняемых приемом вне цикла сканирования. Поведение его как бы состоит из циклов ”планирования” (поиск наилучшего приема при сканировании) и реализации найденного плана. Чем больше необходимых действий вовлекается в этот план, тем меньше будет число сканирований, и тем больше — быстродействие решателя.

Одним из наиболее эффективных средств для ”укрупнения” приемов сканирования задачи оказалось использование в них пакетов ”локальных” приемов, применяемых уже не в контексте сканирования всей задачи, а для обработки каких-либо выделенных подтермов. Такие объединения локальных приемов получили название пакетных операторов. Эффективность их применения объясняется малым числом
используемых приемов и обычно малым по сравнению со всей задачей размером обрабатываемых термов. Приемы пакетного оператора упорядочены по уровням срабатывания, и на каждом уровне организованы в древовидную процедуру, позволяющую отсекать заведомо не реализуемые ситуации. Посимвольного просмотра обрабатываемых термов здесь не происходит — поиск приема выполняется однократным прохождением программы пакетного оператора.

### Недостатки {#disadv-opgroups}

1. Набор пакетных операторов фиксирован. По-видимому, для определения нового пакетного оператора требуется вносить существенные изменения в компилятор ГЕНОЛОГа. Однако введение такого рода операторов может быть полезно при добавлении новой области, где есть класс подзадач, которые можно решать небольшим количеством приёмов. Таким образом, неплохо было бы, чтобы в процессе обучения системы можно было определить новый пакетный оператор (на уровне пользовательского интерфейса, а не компилятора).

  **Возможный путь решения:** добавить возможность при определении приёма указать группу, в которую его следует отнести. Каждая группа тогда оформится в свой пакетный оператор. Для каждой группы можно тогда указать способ явного вызова решения подзадачи при помощи приёмов этой группы. Остаётся, тем не менее, непонятным, как унифицировать способ организации приёмов группы в эффективную процедуру решения задачи. Обычно для задач, решаемых пакетным оператором, существует алгоритм, который и реализуется при компиляции таких приёмов. Однако алгоритм различается для разных операторов. Нужно как-то продумать, как указать компилятору эффективный способ организации программы этих приёмов.

### Пакетные операторы, которые могли бы быть полезны {#addusefulgroups}

1. Построение и быстрая проверка правдободобности гипотез о свойствах функций на основе анализа примеров и графиков (таблиц значений), исходя из того, что может пригодиться при решении задачи.
2. Обращение к внешним программам, которые умеют быстро решать специальные задачи из какого-то класса. Например, Wolfram Mathematica, Sage, Maple и др. Оператор должен проверять, что подзадача соответствует какому-то типу, формулирует её в терминах внешней программы, запускает её, потом интерпретирует и выдаёт ответ.
